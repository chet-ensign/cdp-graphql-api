= Context Server 1.0.0
:toc: macro
:toc: right
:toclevels: 4
:sectnums:
:sourcedir: ../javascript

image::images/OASISLogo.jpg["Oasis Open Logo"]


\[Stage]

01 June 2018

Specification URIs:

This Version:
  http://docs.oasis-open.org/cxs/[additional path/filename].html
  http://docs.oasis-open.org/cxs/[additional path/filename].pdf

Previous Version:
  http://docs.oasis-open.org/cxs/[additional path/filename].html
  http://docs.oasis-open.org/cxs/[additional path/filename].pdf

Latest Version:
  http://docs.oasis-open.org/cxs/[additional path/filename].html
  http://docs.oasis-open.org/cxs/[additional path/filename].pdf

Technical Committee:

OASIS CXS TC

Chair(s):
  Serge Huber
  Thomas Lund Sigdestad

Editor(s):
  Thomas Lund Sigdestad
  [Editor name]

Related Work:
  This specification replaces or supersedes:
  [specifications replaced by this standard - OASIS as well as other standards organizations]
  [specifications replaced by this standard - OASIS as well as other standards organizations]

This specification is related to:
  [specifications related to this standard - OASIS as well as other standards organizations]
  [specifications related to this standard - OASIS as well as other standards organizations]

Declared XML Namespace(s):
  [list namespaces here]
  [list namespaces here]

Abstract:
  [Abstract goes here]

Status:
  This document was last revised or approved by the [TC name | membership of OASIS] on the above date. The level of approval is also listed above. Check the "Latest Version" or "Latest Approved Version" location noted above for possible later revisions of this document.

  Technical Committee members should send comments on this specification to the Technical Committee’s email list. Others should send comments to the Technical Committee by using the “Send A Comment” button on the Technical Committee’s web page at http://www.oasis-open.org/committees/cxs.

  For information on whether any patents have been disclosed that may be essential to implementing this specification, and any offers of patent licensing terms, please refer to the Intellectual Property Rights section of the Technical Committee web page (http://www.oasis-open.org/committees/cxs/ipr.php.

  The non-normative errata page for this specification is located at http://www.oasis-open.org/committees/[specific location].

Notices

Copyright © OASIS® 2018. All Rights Reserved.

All capitalized terms in the following text have the meanings assigned to them in the OASIS Intellectual Property Rights Policy (the "OASIS IPR Policy"). The full Policy may be found at the OASIS website.

This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published, and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this section are included on all such copies and derivative works. However, this document itself may not be modified in any way, including by removing the copyright notice or references to OASIS, except as needed for the purpose of developing any document or deliverable produced by an OASIS Technical Committee (in which case the rules applicable to copyrights, as set forth in the OASIS IPR Policy, must be followed) or as required to translate it into languages other than English.

The limited permissions granted above are perpetual and will not be revoked by OASIS or its successors or assigns.

This document and the information contained herein is provided on an "AS IS" basis and OASIS DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

OASIS requests that any OASIS Party or any other party that believes it has patent claims that would necessarily be infringed by implementations of this OASIS Committee Specification or OASIS Standard, to notify OASIS TC Administrator and provide an indication of its willingness to grant patent licenses to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification.

OASIS invites any party to contact the OASIS TC Administrator if it is aware of a claim of ownership of any patent claims that would necessarily be infringed by implementations of this specification by a patent holder that is not willing to provide a license to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification. OASIS may include such claims on its website, but disclaims any obligation to do so.

OASIS takes no position regarding the validity or View of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on OASIS' procedures with respect to rights in any document or deliverable produced by an OASIS Technical Committee can be found on the OASIS website. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this OASIS Committee Specification or OASIS Standard, can be obtained from the OASIS TC Administrator. OASIS makes no representation that any information or list of intellectual property rights will at any time be complete, or that any claims in such list are, in fact, Essential Claims.

The names "OASIS", [insert specific trademarked names, abbreviations, etc. here] are trademarks of OASIS, the owner and developer of this specification, and should be used only to refer to the organization and its official outputs. OASIS welcomes reference to, and implementation and use of, specifications, while reserving the right to enforce its marks against misleading uses. Please see http://www.oasis-open.org/who/trademark.php for above guidance.

Table of Contents

toc::[]


== Introduction

Today, virtually all business is at some point digital, and the number of systems involved and the set of data collected is growing rapidly.
Each system creates new silos of customer data, spreading sensitive and personal data across both organizational and geographical borders.

Even digital savvy businesses struggle to control and utilize this information.
Businesses and users also rely on such data to be accessible in real-time, and at scale - for instance to deliver personalizations.
Additionally businesses now face severe legal charges if customer data is not treated according to regulatory requirements (ref GDPR).

The Context Server (CXS) specification aims to standardize exchange of customer data across systems and silos.
This enables centralization of customer data - consequently giving control of the data back to the business, and the customers.

The CXS standard builds upon four core concepts: Profiles, Events, Consents, and Clients

  * Profiles represent each individual "customer". Aggregating and tracking all registered properties, including which system actually collected the data.
  * Events represent user behavioral data / interactions performed by a customer (aka profile). A purchase, or a simple click on a link represents different events.
  * Consents are actual permission given by a customer to the organization, with a limited View and duration
  * Clients represent the various systems that provide and/or consume data from a Context Server, typical clients are: CRM systems, Identity Systems, Content Management Systems, E-commerce etc.

The CXS standard is defined as a web-based API using GraphQL - providing a self-documented and strongly typed interface.

It has been an explicit goal of the CXS committee to allow extensive customization of CXS deployments, in order to fit the need of each different organization.
As such, the API dynamically evolves as you customize your deployment.


=== Terminology

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” are to be interpreted as described in [RFC2119].

=== Normative References

\[RFC2119]

S Bradner, Key words for use in RFCs to Indicate Requirement Levels, http://www.ietf.org/rfc/rfc2119.txt, IETF RFC 2119, March 1997.

\[Reference]

\[Full reference citation]



NOTE: The proper format for a citation to an OASIS Technical Committee's work (whether Normative or Non-Normative) is:

OASIS
Stage (Committee Draft 01, Committee Draft 02, Committee Specifcation 01, etc. or Standard)
Title (italicized or in quotation marks)
Approval Date (Month YYYY)
URI of the actual Authoritative Specification (namespace is not acceptable as the content changes over time)

For example:

\[EDXL-HAVE]

OASIS Standard, "Emergency Data Exchange Language (EDXL) Hospital AVailability Exchange (HAVE) Version 1.0", November 2008.
http://docs.oasis-open.org/emergency/edxl-have/os/emergency_edxl_have-1.0-spec-os.doc


=== Non-Normative References

\[Reference]

\[Full reference citation]


== Use Cases

=== Personalization

=== Newsletters

=== Privacy

=== A/B testing



== Domain objects

The ConteXt Server (CXS) standard is built around a set of domain objects, and offers a GraphQL API for interacting with these.
This chapter describes the domain objects in detail.

=== Clients

The CXS GraphQL API is not intended to be exposed publicly, but only made accessible to specific authorized clients.

Client means any software that interacts directly with the Context Server.
A Context Server typically holds personal data, as such implementers are urged to place strong control over which clients can connect to a context server.
In any case, it should not be possible for unauthorized clients to access the context server API.

Examples of clients are:

* Cookie-based tracker for website(s)
* Integration with your CRM
* Integration with your Identity System

Each Client is responsible for uniquely identifying visitors, for instance through the use of a cookie on the website, a customer ID in the CRM or a user ID in the Identity system.
The Context Server requires <<profileIDs>> to be unique within every client.
For instance, if a client is used to track visitors across multiple websites, it should aim to re-use the same profileID across all of them, for the same visitor.

NOTE: The standard does not specify Queries or Mutations for creating or retrieving Clients in the CXS specification, as this is considered an implementation-specific feature.
For any CXS implementation, a Client must be pre-defined in the CXS server before it can access the API.


=== Profiles
Profiles are in many ways the essence of CXS.
A Context Server dynamically builds profiles from events that occur over time.

A Profile can be created from an anonymous visitor on a webpage, or populated from an identity system or maybe a CRM - or the combination of all of them.

Different <<Clients>> like a website tracking script, CRM or identity system can be configured to feed <<Events>> to the context server.

The context server is responsible for building profiles based on the provided identifiers and the stream of events coming from each Client.


=== Properties

A Property is essentially data stored in a key-value format.
A single property can hold a single value, or an array of values.
Each property has a specific valueType to limit what kind of values it may hold.
Examples are Identifier, String, Int, Float, Date, Boolean, GeoPoint and Set.

Some example properties:

* someString : "Thomas"
* someDate : date(1975-10-17)
* someInteger : 1624
* location : geoPoint(x,y)
* arrayOfStrings : ["This", "is", "nice"]
* setOfProperties : {prompt : "hello", response : "yo"}

The valueType Set is special, as it enables nested properties and a tree-structure of properties.
I.e. from the example above: setOfProperties.response would hold the value "yo"

=== PropertyTypes

PropertyTypes are used to dynamically define schemas in the Context Server.
A propertyType essentially defines:

* the property name
* the valueType of the property (Identifier, String, Int, Float, Date, Boolean, GeoPoint and Set)
* minimum occurences of values (a single property may hold one or more values)
* maximum occurences

Since the CXS api is defined using GraphQL, the parts of the API that relates to schemas are dynamically updated when the schema is changed.

See <<CXS_PropertyType>> for more API details.


=== ProfilePropertyTypes

To create a schema for <<Profiles>>, we need a globally defined set of propertyTypes.

Collectively, profilePropertyType defines the schema of properties that can be used by any profile in the Context Server.

This enables administrators and developers to build and maintain a consistent data model for profiles across all <<Clients>>.
Any data imported to the system must be mapped to a corresponding ProfilePropertyType.

A profilePropertyType is technically a PropertyType, where the name must be unique for all profilePropertyTypes.


=== ProfileIDs
Profiles have unique identifiers across different <<Clients>>.
As such the profile ID is a composite value from Client and a unique identifier within that Client.

A ProfileID consists of the following fields:

* ID (mandatory - unique within Client)
* Client (mandatory) # ClientID instead?


=== Events
Events are what drives the Context Server forward.
Events are collected from different Clients, such as a specific website, beacons, commerce systems or a CRM.

A single Client might still produce many different profiles for a "real person".
For instance - if a visitor uses different devices on a single web page, each device will produce a new profile, with a unique profileID.

As such, Context Servers implementations SHOULD support profile merges.

As profiles evolve over time, the context server may discover that two profiles actually represent the same individual i.e. if the same e-mail address is registered in both profiles, or if the user in on both his devices. This may then result in a profile merge.
During a profile merge, the Context Server will link two (or more) separate profiles together.
In order to keep event history and avoid re-processing of data, the merge process must not affect the existing and unique profileIDs.
This is why profiles are defined to have multiple profileIDs.

Example: As such, when visitors on a website are tracked through a cookie (defining the profileID), the cookie will remain the same even if the profile is merged.

The Context Server is essentially interested in "User behavioral events".
An event could be anything from someone clicking a link, to performing a transaction or consenting to use of his/hers information.
Events are streamed or delivered from authorized <<Clients>> to the Context Server.

As an example: Imagine an e-commerce site with a client that collect events from its visitors.
When a visitor browses the site with his laptop, the client assigns a cookie to his/her browser and starts feeding events to the CXS API.
As the visitor click on some product links, and maybe fills in a form that includes e-mail. CXS will gradually populate a profile, using the cookie value as an ID.
At a later point, the same visitor picks up a different device and returns to the site. As the client cannot know this is the same individual, a new cookie is generated, and a new profile starts to build up.

A single client may be used to track <<Events>> from a number of different websites, where each website can be tagged with a source.
Sources provide a way to identify the exact origin of the events beyond the client.
As such, sources are comparable to siteID's in Google Analytics.


=== EventTypes

To uniquely separate events, an event must be associated with a specific EventType.
EventTypes require a unique name, preferably using a namespace to avoid conflicts i.e. cxs_nearBeacon or company_Whatever


=== Consents

New legislation and stricter rules for use of personal data is already here (i.e. GDPR).
As such, consents are inherently more important to ensure you are using and storing data in compliance with policies.

Consents hold an identifier that uniquely identifies the consent across your systems. The

=== Interests

An important use-case for the Context Server is to determine a profiles "Interests".
Whenever the Context server registers an events that are associated with one or more <<Topics>>, this will affect the profile's interest for the specific Topic.
A profiles interest in a specific topic is measured between 0-1, where 1 is maximum. As such 0,5 would indicate a higher interest than 0,35.

The algorithm for how a context server scores and interest is implementation specific
- but implementations should also take care of automatically decreasing interest over time, unless new and relevant events occur.

Example interests for products from a car manufacturer might be:

*  Model S = 0.1
*  Model 3 = 0.3
*  Model X = 0.9

=== Filters

Filters are widely used in CXS, and enable querying profiles, events, and other CXS objects.
Filters are designed to be easy to use for administrators and marketeers in visual user interfaces, but also in terms of technical implementation.

Filters are essentially composed from basic property comparison expressions, and may be chained with the operators AND and OR, where AND is used by default.

A single filter may only operate on a specified CXS object (i.e. profile or event).

The following comparison operators are available:

.Operator availability for property value types
[options="header"]
|=============================================================
|Operators |Identifier|String|Int|Float|Date|Boolean|GeoPoint|
|equals    |x         |x     |x  |x    |x   |x      |x       |
|startsWith|          |x     |   |     |    |       |        |
|endsWith  |          |x     |   |     |    |       |        |
|contains  |          |x     |   |     |    |       |        |
|regexp*   |          |x     |   |     |    |       |        |
|lt        |          |      |x  |x    |x   |       |        |
|lte       |          |      |x  |x    |x   |       |        |
|gt        |          |      |x  |x    |x   |       |        |
|gte       |          |      |x  |x    |x   |       |        |
|distance  |          |      |   |     |    |       |x       |
|between*  |          |      |x  |x    |x   |       |        |
|=============================================================

* optional operators

As we are expressing filters through GraphQL, filters will always be strongly typed.
I.e. if the property "firstName" with valueType string is available, the following options can be used:

  firstName_equals
  firstName_startsWith
  firstName_endsWith
  firstName_contains
  firstName_regexp (optional)

Below are some basic filter examples:

  { "firstName_equals" : "Serge" }

  { "birthDate_greaterThan" : "1970-01-01" }

  { "location_distance" : {
    "center" : { "longitude" : 59.91273, "latitude": 10.74609 },
    "unit" : "KILOMETERS",
    "distance" : 5
    }
  }

  {
    "or" : [
      { "firstName_equals" : "Serge" },
      { "birthDate_greaterThan" : "1970-01-01" }
    ]
  }

=== OrderBy

OrderBy is used in combination with filters and lets you sort the result based on properties available for the returned objects.

Example:

  "orderBy": [{
    "property": "firstName",
    "order": "ASC"
    }
  ]


=== EventFilters

EventFilters are a specific version of filters for querying events.

Example: Filter for identifying events of type `transaction` within the last 30 days.

  {
    "properties" : {
        "timestamp_between" : { "after" : "2018-06-28T05:25:28+00:00", "before" : "2018-06-28T06:25:28+00:00", includeBefore : false, includeAfter : true },
        "cxs_UpdateProfile" : {
          "updateProperties": {
            "firstName_startsWith" : "T"
            "lastName_endsWith" : "d"
          }
        }
    },
    "eventOccurrence": { "eventId": "transaction",   "count": 1,  "afterTime": "now-30d" }}
  }


=== ProfileFilters

Profile Filters are slightly more complex than <<EventFilters>>.
As profileFilter are composed from the following:


=== Views

Views provide a way of grouping administrative objects in the context server.
<<Profiles>>, <<Events>> and <<Consents>> are all collected and stored globally,
but other items are typically handled by administrators or marketeers, and benefit from being grouped into different views to simplify handling.

<<Lists>>, <<Segments>>, <<Topics>> and <<Personas>> are all tagged with Views.


=== Personas

A persona is a concept used by marketeers to visualize one or more target customers, and simplify personalization and targeting of content.

In CXS, personas are essentially "dummy" profiles with the primary purpose of testing or emulating a real profile.
A common use-case would be testing personalized content in a CMS or a newsletter.

Personas and their fields can be explicitly created, where real profiles are built from a stream of events.


=== Lists

Lists are explicitly created and named in the Context Server. Profiles may then be added to a list, and later opt out if desired.
Whenever a profile opts out of a list, that information will also be stored. This prevents the profile from accidentally being added back to the list at a later point.

A common use-case for lists is creating a list for a campaign, and add the target profiles to the list as the campaign starts.


=== Segments

Segments are similar to lists in that profiles may be in the segment, or not.
However, where profiles are explicitly added to lists, they are dynamically resolved to segments based on the filter defined in the segment.

Administrative users define segments through <<Filters>>.

Example segments:
* Rich europeans: Profiles in Europe with income above €100k
* Frequent buyer: Profiles that have completed more than 5 transactions in the last 3 months
* Etc


=== Topics

Topics represent the core entities of the business that is using the Context Server.
The Context Server aims to find correlation between profiles and the topics.
When such correlations are identified, it is called <<Interests>>.

CXS Administrators need to maintain a list of topics in order to obtain profile interests.
Profile interests is typically a core objective of Marketing activities, and targeting users with better content.

Example Topics for a car manufacturer might for instance be:

* "Model S"
* "Model 3"
* "Model X"

TODO: What about localization?


== GraphQL Type definitions

=== CXS_Consent

* Name (Mandatory) - String that identifies the consent, i.e. a url or a reverse domain notation org.cxs.newsletter
* Status - one of GRANT, DENY or REVOKED
* StatusDate - Date when status was last updated
* revokeDate - Revocation date, SHOULD have a default value like two years if left blank
* View TODO: Why???
* Source - Identifying the source of this consent? Optionally accessible from Profile?
* Events - All events related to this consent
* Profile - The profile this consent applies to


=== CXS_Event

[source,graphql]
----
include::{sourcedir}/schemas/events.js[lines=2..76]
----

==== CXS_EventFilterInput

==== CXS_EventType

[source,graphql]
----
include::{sourcedir}/schemas/events.js[lines=2..40]
----

=== CXS_Interest

[source,graphql]
----
include::{sourcedir}/schemas/interests.js[lines=2..10]
----


=== CXS_List

* ID (mandatory)
* Title (mandatory string)
* View
* Profiles - Active profiles in the list
* Inactive - Profiles that have been deactivated



=== CXS_Persona

[source,graphql]
----
include::{sourcedir}/schemas/personas.js[lines=2..24]
----

=== CXS_Profile

[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=2..25]
----

==== CXS_ProfileProperties

[source,graphql]
----
include::{sourcedir}/schemas/profileproperties.js[lines=2..15]
----

==== CXS_ProfileFilterInput

* asString - Filter expressed as a string
* properties - Profile properties
* Segments - that the profile must match
* Consents - granted by the profile
* Events - profileEventsFilter (TODO)

ProfileFilters only return profiles that match the combined filter expressions.

==== CXS_ProfileID


=== CXS_PropertyType

CXS_PropertyType is to be considered an interface, with implementations for each valueType.
This simplifies use and provides strong typing in GraphQL.

[source,graphql]
----
include::{sourcedir}/schemas/propertytypes.js[lines=2..27]
----

==== CXS_BooleanPropertyType

[source,graphql]
----
include::{sourcedir}/schemas/booleanpropertytypes.js[lines=2..23]
----

==== CXS_DatePropertyType

[source,graphql]
----
include::{sourcedir}/schemas/datepropertytypes.js[lines=2..23]
----

==== CXS_FloatPropertyType

[source,graphql]
----
include::{sourcedir}/schemas/floatpropertytypes.js[lines=2..23]
----


==== CXS_GeoPointPropertyType

[source,graphql]
----
include::{sourcedir}/schemas/geopointpropertytypes.js[lines=2..23]
----

==== CXS_IdentifierPropertyType

[source,graphql]
----
include::{sourcedir}/schemas/identifierpropertytypes.js[lines=2..23]
----

==== CXS_IntPropertyType

[source,graphql]
----
include::{sourcedir}/schemas/intpropertytypes.js[lines=2..23]
----

==== CXS_StringPropertyType

[source,graphql]
----
include::{sourcedir}/schemas/stringpropertytypes.js[lines=2..23]
----

==== CXS_SetPropertyType

[source,graphql]
----
include::{sourcedir}/schemas/setpropertytypes.js[lines=2..23]
----



=== CXS_Segment

[source,graphql]
----
include::{sourcedir}/schemas/segments.js[lines=2..14]
----


==== CXS_SegmentFilterInput

[source,graphql]
----
include::{sourcedir}/schemas/segmentfilterinput.js[lines=2..10]
----


=== CXS_Topic

[source,graphql]
----
include::{sourcedir}/schemas/topics.js[lines=2..12]
----



=== CXS_View

* Name (mandatory, unique identifier)



== GraphQL Queries

== GraphQL Mutations

== GraphQL Subscriptions

TODO

== Conformance

conformance clauses/statements go here

== Appendix A. Acknowledgements

The following individuals have participated in the creation of this specification and are gratefully acknowledged:
Participants:

\[list of acknowledgements as determined by Technical Committee chair(s)]

== Appendix B. Non-Normative Text

[any additional appendices for non-normative text here]

== Appendix C. Revision History

\[Required in all approved Work Products]
Revision 	Date 	Editor 	Changes Made
